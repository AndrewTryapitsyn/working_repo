
----------git--------------
--version control--

git config --list
git status

.gitignore 		- file what will be igrore for watching
git add 		what will be commited
git add . 		- add files in llocal directory(/dir1/) what will be commited
(it is good to separate filees to be commited for easy rollback)
git reset HEAD  	to remove files from stage status
git commit -m "message about update" 	without -m you have to edit file
git checkout --<file|. for all files> - to rollback to previous state
git diff 		- show changes from previous stage
git log		


---github---
--storage for git--
ssh-keygen -t rsa -b 4096 -C "pyneng.course@gmail.com"
eval  "$(ssh-agent -s)" chech if it is working
ssh-add  ~/.ssh/id_rsa  	-add key to dir
add key to github throught web
settings->ssh and GPG keys-> add new and copypast from file  ~/.ssh/id_rsa.pub
ssh -T git@github.com

cd
git clone git@github.com:.....git

git push origin master 	origin server's name master -branch
git pull			download changes from github
git diff HEAD..origin		to see changes befor pull

or create a new repository on the command line
echo "# test" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin git@github.com:AndrewTryapitsyn/test.git
git push -u origin master


…or push an existing repository from the command line
git remote add origin git@github.com:AndrewTryapitsyn/test.git
git push -u origin master


git pull  git@github.com:AndrewTryapitsyn/working_repo.git master

----------------------------------------------------------------
pip 
pip3

pip --version
python3 -m pip install	to be sure about version of pip and python


----------virtual environment-------
isolate projects, with different versions of packets, python versions

virtualenvwrapper  help to work with virtual environments
sudo pip install virtualenvwrapper
.bashrc
export WORKON_HOME-~/venv
. /usr/local/bin/virtualenvwrapper.sh

create a new virtual env with by default Python3.6
mkvirtualenv --python=/usr/loacl/bin/python3.6 pyneng

workon pyneng 	swithc to virtual environment
deactivate		logoff from virt env
rmvirtualenv Test


-----------------------
round(10/3, 3)  = 3.333 up to 3
round(10/3)       =3
3**4   =81
10%3 = 1  остаток

a+=5
a = '11'
int(a) = 11
bin_a = '101010100'
int(bin_a, 2) = 340
bin(255) = 0b1111111
hex(255) = 0xff

неизменямый тип
type('qwe')  == str
str(5) = '5'
line = 'don\'t'    \' 
line = "don't"
line ='''testtesttest
	stilltest'''
str1 = 'line1'
str2 = 'line2'
str1 + str2   == 'line1line2'
str1*2 = 'lin1line1
'#'*50  == '##############################'

str1[0] = 'l'
str[-1] = '1'
str[0:2] = 'li'
str[2:] = ne1
str[-3:0]
str[0:-1]
str3= '123456789'
str3[::2] = '13579'
str2[::-1] = '987654321'
line  = 'FastEthernet0/1FastEthernet0/1'
line.count('Fast') == 2
len(line) == 20
line.find('Ether') = 4
line.startswith('Fast') == True | endswith()
line.replase('0/1', '0/3')  == 'FastEthernet0/3FastEthernet0/3'
line.replase('0/1', '0/3',1)  == 'FastEthernet0/3FastEthernet0/1'
line.strip()|lstrip()|rstrip()
line.strip()
line = [80/110]
line.strip('[]') = 80/110
line = '1,3,4,5'
line.splite() = ['1','3','4','5']

tempate = '''
		IP address: {}
		Mask:		{}
		Interface	{}
		'''
template.format('10.1.1.1', 24, 'Gi0/0')

{:7} ширина 7 символов
{:b} преобразовать Int в двоичную
{:08b} добавить 0 до 8 символлов
{:<}
{:>}	выравнивание
temp2 = '''IP: {0}/{1}
		IP:		{0}
		Mask:	{1}
		'''
temp2.format(10.1.1.1', 24)	
temp2 = '''IP: {ip}/{mask}
		IP:		{ip}
		Mask:	{mask}
		'''	
temp2.format(ip = '10.1.1.1', mask = 24)


list
list1 = list('router')
list1 = [1,2,3]
генератор списка
list1 = ['FastEthernet0/' + str(i) for i in range(10)]
list1 = 'FastEthernet0/1'
		'FastEthernet0/2'
		'FastEthernet0/3'
		...
		'FastEthernet0/8'		
		'FastEthernet0/9'

list1 = [10,20,30]
list1[::-1] == 30,20,10 same rules as str
--------
list2=list1  link to the same object
list2[0] = 100
list1 == list2 ==100,20,30
--
list3 = list1.copy() create a copy
-------------
list1.append(40)
list1.extend([40,50])  
list1.insert(2,25)
list1.pop()		remove by default last index| or specifix index
list1.remove(20) remove by value
list1 = [5,2,1,4,3]
list1.sort()!! list1 == 1,2,3,4,5 !!!will sort list1 do not return result so if res = list1.sort(); res == null
sorted()      !!!use sorted instead
','.join(vlans)

---------------dict--------------
r1 = {'location':'IT'}
r1 = dict(location='IT', serial='aaaaa')
d_keys = ['hostname','location','vendor','model']
dict.fromkeys(d_keys) 			with None by default
dict.fromkeys(d_keys, False)	or with values, but do not create different values, rather link to the same value, for example link to the same list
d = {key:[] for key in d_keys}	same but create a separate object for each value


del r1['location']  delete key
r1.get('loac',10) return 10 if don't have key
r1.setdefault('location') return value if we have this key, if we don't have create new key and set value to None
r1.keys(),values().items() - special object , not regular list
l1 = r1.keys()			- link to r1.keys() and not a separate object
l2 = list(r1.keys())	- copy of keys

r.update(new_data)		- update old keys with new data, if key is not exist create a new



-------------tuple------
t = (1,)
-------set--------
set1 = set()
set1 = {1,2,3,4,5,6}
{item  ** 2 for item in [1,2,3,4]}


set1.add(2)
set1.discard(2)
vlans1&vlans2  == intersection
vlan1|vlans2   union
vlan1 - vlans2 difference



------------
add to file for executing python
python --version
python3.6 --version

#!/usr/bin/env python3
#!/usr/bin/env python3.6
chmod +x qwe.py


import sys
print(sys.argv)

test.py "gi 0/1"   -  'test.py' 'gi 0/1'
test.py 10 155 240

['access_template_argv.py','g0/0','10']
intf,vlan = args
interface,vlan = argv[1:]

vlan = input('input vlan')   # do not use for passwords

d= {1 : 'is equal to 1', 2 : 'is equal of 2', 3 : 'is equal of 3'}
print(d.get(int(input('input number')),' not equal to 1,2,3'))

if False:  == if None: == if 0:  == ()  == {}  == []  == ''  == len(list())!= 0
else: print('False')

l1= [1,2,3]
is_list = type(l1) == list
not_empty = len(l1) !=0 
if is_list and not_empty:


d = {1:10,2:20,3:30}
for key,value in d.items:
    print(key,value)


while true:

    if k == 1:
        contunue    jump to start while
    if k==2:
        break       end of while
    if k==4:
        pass        don't do nothing, just like temp if you don't know yet- vlans2 difference

-----------



-----------

try:
	result = a / b
except ZeroDivisionErroe:
	print('error')
else:					# if there wasnt any execepts
	print(result)
finaly:
	print('always executed')

-------


with  open('r1.txt') as f:		context manager
	print(f.read()) 	read all file in one string
	
f = open('r1.txt','r')		r,r+(read + write),w(clear file write to it),a(append)
f.read()		read all file in one line
f.readline()	read only one string from file
while True:
	line = f.readline()		when we don't have string, it is returning ''
	print(line)
	if not line:
		break
with open('r1.txt') as f:	read only one line from file(if large file it is better)
	for line in f:
		print(line)
		
f.readlines()	read file in list
	
f = open('new_file.txt','w')	
f.write('line')			write in one line
f.write('line1')		== lineline1

f.writelines(list1) 	write list into file, do not add any '\n'
f.close()
f.closed()				return True if it is closed

with open('r1.txt') as src, open('result.txt','w') as dest:
	for line in src:
		if line.startwith('service'):
			print(line)
			dest.write(line)	

----------------------------
--------------
unpacking variables 
a,b = 3,50
ip,mask,mac = ['10.1.1.1','24','aaaa.bbbb.cccc']
vlan,mac,_,intf = '100	01bb.c555.7000 DYNAMIC	Gi0/0'.split()	_ is using if you don't need this value
vlan,mac,*rest,intf = '100	01bb.c555.7000 DYNAMIC	Gi0/0'.split()

num = [1,2,3,4,5]
first,second,*rest = num
firs = 2 ; second = 2 ,rest = [3,4,5]
*rest, first,second  = num
firs = 4 ; second = 5 ,rest = [1,2,3]

r1= {
    'location': '21 New Globe Walk',
    'vendor': 'Cisco',
    'model': '4451',
    'ios': '15.4',
    'ip': '10.255.0.1'	
for key,value in r1.items():
	print(key,value)
	
	
------------list comprehensions---------(list generator)
ip = '10.1.1.1'
result = [int(octet) for octet in ip.split('.')]  # firs go value for list , second from there
==
for octet in ip.split('.'):
	result.append(int(octed))
	
['vlan {}'.format(num) for num in [1,14,50,100]]

items = [10,'a',40,'s',100]
for item in items:
	if type(item) == int:
		result.append(item)
		
result = [ item for item in items if type(item) == int]  == [10,40,100]
result = { item for item in items if type(item) == int}

k = ', '.join(item for item in items if item.isalpha())  --generator expresion


--------------
def sum(a,b,verbose=True)		c - unnecessary argument, with default value| do not use [],{} better None
'''Docstring - describe information about the function'''
	if verbose: print(a,b)
	return a+b	
# if return several values it will return tuple = (a,b)
	return a,b 

import ipaddress
def check_ip(ip_address):
	try:
		ipaddress.ip_interface(ip_address)
		return True
	except ValueError as err:
		return False
-----------------

def f(*vargs)
	print(vargs)
f(1,2,3,4)  == (1,2,3,4)

def f(**kwargs)
	print(kwargs)
print(a=1,b=2)  == {'a':1,'b':2}

unpacking arguments
template = '{}{}{}{}'
ip = '10.1.1.1'
ipl = ip.split('.')
template.format(*ipl)

def f(a,b,c)
	return a+b+c
d = {'a':1,'b':10,'c':44}
f(**d) == 55

def donncet_ssh(ip,user,password,timout = 10, strip_prompt=True)
		print(ip,user,password,timeout,strip_prompt)
def conncetc_to_ip_list(ip_list,user,password,**kwargs):
	print(kwargs)						== {'timeout':10,'strip_prompt':False}
	for ip in ip_list:
		connect(ip,user,password,**kwargs)

conncetc_to_ip_list('10.1.1.1','cisco','cisci',timeout = 10,strip_prompt=False)


---------------------------
print(*items, sep=' ',end='\n', file=sys.stdout,flush=False)   -flush do not wait for \n to bufferize, immediate print

randge(start,stop,step )
randge(0,10,-1)
5 in range(0,10)
sorted((1,2,3,4,5)) always return list
sorte even subobjects, firstly for 1 key, second,...
from operator import itemgetter
sorted(data,key = itemgetter(1)) can sort not only by first value

import time
time.sleep(1)
----------------
from sys import *     never use , because  could not recognizr from where

# do not start with import
if __name__ == '__main__':
	your code

sys.path show all directories to check for modules
sys.path.append('../09_fuctions/')  temporary add path

---------------------------
	vlan =['2','100','1000','200']
sorted(vlan,key = int) sort by value og numbers
sorted(vlan, key =len, reverse = True) sort by lendgth in opposite direction
key = str.lower,

enumerate(data, startfrom)  asign  numbers for data
list(enumerate([10,20,30,40,50]))   == [(1,10),(2,20),(3,30),(4,40),(5,50)]
for idx,item in enumerate(data,1):
	print(idx,item)					== 1 date1
										2 data2
key = ['protocol','prefix','interface']
value = ['ospf','10.1.1.1','fa0/1']										
dict(zip(key,value))			-- cut to the lower number of elements							

all()		return True if all elements is True or []
ip = '10.1.1.1'
all([octet.isdigit() for octet in ip.split('.')])  return True if all digits

any()		if any element True, return True

ignor = ['alias','config','!']
any([word in line for word in ignor]) return True if we have a ignore word in line
-------------

import time
time.sleep(1)
-------------------
import sys				in both cases execute all module sys, here sys.argv
from sys import argv	but here argv is accesible as variables not sys.argv but argv 


sorted(data, key = lambda x: x[1]) sort by [1] column

lambda   function without a name:
def dum(a,b): return a+b
sum_arg = lambda a,b: a+b



vlans = ['1','10','100','200']
[int(item) for item in vlans]
list(map(int,vlans))   == [1,10,100,200]

map(first,second)   first - transformation function, second - elements
map apply 'first' function to each element 
 
['vlan {}'.format(vl) for vl in vlans]
list(map(lambda vl:'vlan {}'.format(vl), vlans))

vlans = ['1','10','100','200','a']
filter(first, second)   the same apply function 'first' to each element and return only elements with True value 
list(filter(str.isdigit,vlans))
--------------------

subprocess  create a new proccess, cound run any Linux commands(ping...)
import subprocess
return = subprocess.run('ls') or run('ls', shell = True)
return.returncode , stdout

result = subprocess.run('ping 8.8.8.8 -c 5 -n',shell = True, stdout = subprocess.PIPE)
result.stdout will return output but return in bytes b'strstr'
resut.stdout.decode('utf-8') will return normal string or:
result = subprocess.run('ping 8.8.8.8 -c 5 -n',shell = True, stdout = subprocess.PIPE, encoding='utf-8')

result = subprocess.run('ping 8.8.8.8 -c 5 -n',shell = True, stdout = subprocess.PIPE, stderr=subprocess.PIPE)
in case of failure we can get result.stderr


os
working with filesystem
import os
os.mkdir('test')
if not os.path.exists('test')
	os.mkdir('test')
os.listdir('.')
os.path.isdir('test')

import ipaddress
ip1 = ipaddress.ip_address('8.8.8.8')

net1 = ipaddress.ip_network('10.1.1.1/24')
net1.with_hostmask == wildmask
net1.with_netmask,prefixlist
for ip in net1:
	print(ip) all ip in network
net1[4] == '10.1.1.4'

net1.subnets(new_prefix=30)

intf1 = ipaddress.ip_interface('10.1.1.195/28')
intf1.netmask,network,withprefixlen



tabulate
pip install tabulate

import tabulate
from tabulate import tabulate
print()

sh_ip_int_br = [('FastEthernet0/0', '15.0.15.1', 'up', 'up'),
...: ('FastEthernet0/1', '10.0.12.1', 'up', 'up'),
...: ('FastEthernet0/2', '10.0.13.1', 'up', 'up'),
...: ('Loopback0', '10.1.1.1', 'up', 'up'),
...: ('Loopback100', '100.0.0.1', 'up', 'up')]

print(tabulate(sh_ip_int_br))
--------------- --------- -- --
FastEthernet0/0 15.0.15.1 	up up
FastEthernet0/1 10.0.12.1 	up up
FastEthernet0/2 10.0.13.1 	up up
Loopback0 		10.1.1.1 	up up
Loopback100 	100.0.0.1 	up up

columns=['Interface', 'IP', 'Status', 'Protocol']
print(tabulate(sh_ip_int_br, headers=columns))
Interface 			IP 		Status 	Protocol
--------------- --------- -------- ----------
FastEthernet0/0 15.0.15.1 		up 		up
FastEthernet0/1 10.0.12.1 		up 		up
FastEthernet0/2 10.0.13.1 		up 		up
Loopback0 		10.1.1.1 		up 		up
Loopback100 	100.0.0.1 		up 		up

headers=«firstrow»
headers='keys' to take header from dictionary keys
tablefmt="grid"
tablefmt='pipe'
tablefmt='html'
stralign='center'

pprint
from pprint import pprint
pprint(somedict)
pprint(somedict,dept=1)  depth of the dictionary (1 only keys, 2 - keys +values, etc)

argparse
---------------------------
reg
match = re.search('(\S+) +(\d+\.\d+\.\d+\.\d+\)',line)
if did't find anithing return None,  or return FIRST match
match.group() - full export
match.groups() - list of elements with ()

\d any digits
\D except digits
\s any whitspace(\t\n\r\f\v)
\S except whitespace
\w	any char or digit
\W	except char or digit

+
*
? one or zero match
{n} n matchs
{n,m} from n to m matchs
{n, } n or more match

^ start
$ end
[abc] any symbol in brackets
[^abc] except symbols
[a-z]
a|b a or b

by default жадность
disabe +? or *?
---------------------------
		
print(*items, sep=' ',end='\n', file=sys.stdout,flush=False)   -flush do not wait for \n to bufferize, immediate print

randge(start,stop,step )
randge(0,10,-1)
5 in range(0,10)
sorted((1,2,3,4,5)) always return list
sorte even subobjects, firstly for 1 key, second,...
from operator import itemgetter
sorted(data,key = itemgetter(1)) can sort not only by first value

import time
time.sleep(1)



from sys import *     never use , because  could not recognizr from where

# do not start with import
if __name__ == '__main__':
	your code

sys.path show all directories to check for modules
sys.path.append('../09_fuctions/')  temporary add path

re
match 
raw strings  r'\S+\1' == '\\S+\\1'
matchh =re.search(r'Host (\S+) in vlan (\d+) is flapping between port (\S+) and port (\S+)',log2)
group() or group(0) all expresion
group(1) == host MAC
group(2) == vlan   
...
 string - original string
 re  - regular existing
 start() - first symbol number
 end()   last symbol number
 span() - return start and end in tuple
 lastgroup - return last group in ()
 lastindex - return last indx of groups ()

def func():
	result = {}
	regex = ('Device ID: (?P<device>\S+)|'
			'Platform: (?P<plaatform>\S+ \S+),|'
			', Version (?P<ios>\S+),|'
			' IP address: (?P<ip>\S+)')
	with open(filename) as f:
		for line in f:
			match = re.search(regex,line)
			if match:
				if match.last == 'device':
					device = match.group('device')
					result[device] = {}
				else:
					group = match.lastgroup
					result[device][group] = match.group(group)
	return result
 
 
 match similar to search but look only starting from the beggining of string
 
 finditer   used with full file return iterator, can be used only once
result = re.finditer(r'(\S+) +(\S+).+',f.read())
for match in result:
	print(match.groups())
	
re.(regex,line,re.DOTALL()) - .+ will include \n


re.findall()  to full file 
if 1 group () list of this group
if several groups () list of touple
if no groups ()  list of strings full match


re.split(r'[ ,.\[\]]+', ospf_route)
re.sub() 
re.sub()  same as replace only with regexp
re.sub( )



hi = 'hello, наташа'
hi.encode('ascii', 'replace') == b'hello, ?????'
hi.encode('ascii', 'namereplace') == will insert name CYRILIC SMALL LETTER A ,...
hi.encode('ascii', 'ignore') == b'hello, '



csv
import csv
with open('sw.csv') as f:
	reader = csv.reader(f,delimiter=';') by defaulr delimier = ','
	headers = next(reader) # will read header first
	for line in reader:
		print(line)
		
with open('sw.csv') as f:
	reader = csv.DictReader(f) - will read Dictionary with keys from header
	for line in reader:
		print(line)		

with open('sw.csv','w') as f:
	writer = csv.writer(f)  | writer = csv.writer(f,quoting = csv.QUOTE_ALL)
	for line in data:
		writer.writerow(line)	 will write lines without ''
		writer.DictWriter(f,fieldnames=list(data[0].keys()))
		writer.writeheader() - by default dont write headers
		
		
JSON
Python		JSON
True		true
False		false
dict		obj
list,tuple	array
None		null

import json
string1 = """s:['a','b']"""
data=json.loads(string1)	loads working with strings
with open(fname) as f:
	data = json.load(f)		load working only with files
		
		
with open(fname,'w') as f:
	json.dump(data,f)			compact type
	json.dump(data,f,indent=2)	human like format 
	json.dump(data,f,indent=2,sort_keys=True)	human like format 	
21:30


json 

keys could be only string not numbers


yaml

pip install pyyaml

import yaml
# comment
uses spaces to indicate structure like in python
list-
[1,2,3,4,5]
or (- space on each line)
- 1
- 2
- 3
- 4

dict:

[1:2,2:3]
or :
1:2
2:3

string: "" not necessary but if you have special symbols you need to use it

dict with lists as values:

access:
- switchport
- vlan
trunk:
- mode trunk
- allowed vlans 4

list of dicts
- BS: 1550
  TT:791
  id:11
- BS : 1510
  TT: 792
  id: 10
  
 import yaml
 with open('test.txt') as f:
	data = yaml.load(f)
	
with open('test.txt','w')as f:
	yanl.dump(data,f)  , default_flow_style = False



%history   in ipython
pythontutol
pdb   - debuger



sqlite
.help
.exit , .quit
.databases
.tables
sqlite don't care about data type, could be safe anythng
CREATE table switch (
	mac text not NULL primary key,
	hostname	text,
	model	text,
	location	text
);

.schema print table structure

INSERT into switch values ('aaaa.aaaa.aaaa','sw1','Cisco 3750','London,Green str');
INSERT into switch (mac,model,location,hostname)
values ('aaaa.aaaa.aaaa','sw1','Cisco 3750','London,Green str');

SELECT * from switch;
.headers ON			- enable headers
.mode column		- more attractive view(separate by tab enstead of |)

.read finename - read from file

SELECT * from switch WHERE model = 'Cisco 3850';    should be exact match
SELECT * from switch WHERE model like '%3750' and hostname like 'sw%';

like:
_ - one symbol or number
% - zero or more 

glob:
* - zero or more symbols
? - any single character
[78]
[a-z]

SELECT * from switch WHERE model glob '*3[78]50*';
